\begin{savequote}[45mm]
\ascii{Write programs for people first, computers second.}
\qauthor{\ascii{- Steve McConnell}}
\end{savequote}

\chapter{用例设计} 
\label{ch:test-case}

\section{Fixture}

\begin{content}

\subsection{Fixture}

\begin{leftbar}
\begin{c++}[caption={test/quantity/LengthTest.cpp}]
#include <magellan/magellan.hpp>

FIXTURE(LengthTest)
{
};
\end{c++}
\end{leftbar}

\ascii{FIXTURE}的参数可以是任意的\ascii{C/C++}标识符。一般而言，将其命名为\ascii{CUT(Class Under Test)}的名字即可。

% \subsection{Setup/Teardown提取公共代码}

% \begin{leftbar}
% \begin{c++}[caption={test/quantity/LengthTest.cpp}]
% #include <magellan/magellan.hpp>

% FIXTURE(PerformanceTest)
% {
%     SETUP()
%     {
%     }

%     TESTDOWN()
%     {
%     }
% };
% \end{c++}
% \end{leftbar}

% 其中，\ascii{SETUP/TEARDOWN}为可选，如果未配置，则默认为空。

% \subsection{标记的Fixture}

% 除第一个参数是必选之外，\ascii{FIXTURE}的其他参数为可选参数。当最后的一个可选的参数为标准的字符串字面值，则该参数常常做为\ascii{Fixture}的\ascii{Tag}，其中\ascii{Tag}以\ascii{@}开头。需要注意的是，做为\ascii{Tag}的字符串参数必须是\ascii{Fixture}的最后一个参数。

% \begin{leftbar}
% \begin{c++}[caption={test/quantity/Length.cpp}]
% #include <magellan/magellan.hpp>

% FIXTURE(SaveEnergyTest, "@night")
% {
% };
% \end{c++}
% \end{leftbar}

\end{content}

\section{Test}

\begin{content}

\subsection{自动标识}

\ascii{Magellan}能够自动地实现测试用例的标识功能，用户可以使用字符串来解释说明测试用例的意图，使得用户在描述用例时更加自然和方便。

\begin{leftbar}
\begin{c++}[caption={test/quantity/LengthTest.cpp}]
#include <magellan/magellan.hpp>
#include "quantity/length/Length.h"

USING_HAMCREST_NS

FIXTURE(LengthTest)
{
    TEST("1 FEET should equal to 12 INCH")
    {
        ASSERT_THAT(Length(1, FEET), eq(Length(12, INCH)));
    }

    TEST("1 YARD should equal to 3 FEET")
    {
        ASSERT_THAT(Length(1, YARD), eq(Length(3, FEET)));
    }

    TEST("1 MILE should equal to 1760 YARD")
    {
        ASSERT_THAT(Length(1, MILE), eq(Length(1760, YARD)));
    }
};
\end{c++}
\end{leftbar}

\subsection{面向对象}

\ascii{Magellan}实现\ascii{xUnit}时非常巧妙，使得用户设计用例时更加面向对象，例如下例。

\begin{leftbar}
\begin{c++}[caption={test/robot-cleaner/RobotCleanerTest.cpp}]
#include "magellan/magellan.hpp"
#include "robot-cleaner/RobotCleaner.h"
#include "robot-cleaner/Position.h"
#include "robot-cleaner/Instructions.h"

USING_HAMCREST_NS

FIXTURE(RobotCleanerTest)
{
    TEST("at the beginning, the robot should be in at the initial position")
    {
        RobotCleaner robot;

        ASSERT_THAT(robot.getPosition(), is(Position(0, 0, NORTH)));
    }

    TEST("left instruction: 1-times")
    {
        RobotCleaner robot;

        robot.exec(left());
        
        ASSERT_THAT(robot.getPosition(), is(Position(0, 0, WEST)));
    }

    TEST("left instruction: 2-times")
    {
        RobotCleaner robot;
        
        robot.exec(left());
        robot.exec(left());
        
        ASSERT_THAT(robot.getPosition(), is(Position(0, 0, SOUTH)));
    }
};
\end{c++}
\end{leftbar}

用例之间存在重复代码，为了改善设计，首先将所有用例使用的\ascii{RobotCleaner}对象直接定义在类体里即可。但在运行时，每个用例可得到独立的\ascii{RobotCleaner}实例。

\begin{leftbar}
\begin{c++}[caption={test/robot-cleaner/RobotCleanerTest.cpp}]
#include "magellan/magellan.hpp"
#include "robot-cleaner/RobotCleaner.h"
#include "robot-cleaner/Position.h"
#include "robot-cleaner/Instructions.h"

USING_HAMCREST_NS

FIXTURE(RobotCleanerTest)
{
    RobotCleaner robot;

    TEST("at the beginning, the robot should be in at the initial position")
    {
        ASSERT_THAT(robot.getPosition(), is(Position(0, 0, NORTH)));
    }

    TEST("left instruction: 1-times")
    {
        robot.exec(left());        
        ASSERT_THAT(robot.getPosition(), is(Position(0, 0, WEST)));
    }

    TEST("left instruction: 2-times")
    {
        robot.exec(left());
        robot.exec(left());        
        ASSERT_THAT(robot.getPosition(), is(Position(0, 0, SOUTH)));
    }
};
\end{c++}
\end{leftbar}

\subsection{提取函数}

提取相关的函数，改善用户的表达力。提取的相关子函数，可以放在\ascii{Fixture}的内部，使得用例与其的距离最近，更加体现类作用域的概念。

\begin{leftbar}
\begin{c++}[caption={test/robot-cleaner/RobotCleanerTest.cpp}]
#include "magellan/magellan.hpp"
#include "robot-cleaner/RobotCleaner.h"
#include "robot-cleaner/Position.h"
#include "robot-cleaner/Instructions.h"

USING_HAMCREST_NS

FIXTURE(RobotCleanerTest)
{
    RobotCleaner robot;

    void WHEN_I_send_instruction(Instruction* instruction)
    {
        robot.exec(instruction);
    }

    void AND_I_send_instruction(Instruction* instruction)
    {
        WHEN_I_send_instruction(instruction);
    }

    void THEN_the_robot_cleaner_should_be_in(const Position& position)
    {
        ASSERT_THAT(robot.getPosition(), is(position));
    }

    TEST("at the beginning, the robot should be in at the initial position")
    {
        ASSERT_THAT(robot.getPosition(), is(Position(0, 0, NORTH)));
    }

    TEST("left instruction: 1-times")
    {
        WHEN_I_send_instruction(left());
        THEN_the_robot_cleaner_should_be_in(Position(0, 0, WEST));
    }

    TEST("left instruction: 2-times")
    {
        WHEN_I_send_instruction(repeat(left(), 2));
        THEN_the_robot_cleaner_should_be_in(Position(0, 0, SOUTH));
    }

    TEST("left instruction: 3-times")
    {
        WHEN_I_send_instruction(repeat(left(), 3));
        THEN_the_robot_cleaner_should_be_in(Position(0, 0, EAST));
    }

    TEST("left instruction: 4-times")
    {
        WHEN_I_send_instruction(repeat(left(), 4));
        THEN_the_robot_cleaner_should_be_in(Position(0, 0, NORTH));
    }
};
\end{c++}
\end{leftbar}

\end{content}

% \section{Notation}

% \begin{content}

% \end{content}

